---
isTimeLine: false
title: 12-16
date: 2020-12-16
tags:
 - 备战春秋
 - 复习自查
author: 粥里有勺糖,lj,tdk,tl,fyx
---
# 12-16

TODO: 单独重新梳理相关知识点

## 操作系统
1. 什么是死锁，产生原因，如何预防，如何破解

* 跳转->[操作系统 - 死锁](./../../computerBase/os/deadlock.md)

<my-details title="同学1的回答">

**什么是死锁：** 死锁是指任务因为申请不到资源而被无限阻塞的情况

**原因：** 任务之间互相等待彼此拥有的资源

**预防：** 通过避免死锁的算法可以保证资源的分配都是安全的。如线性资源分配法、系统安全状态法、系统安全状态法

**破解：** 破坏死锁产生的四个必要条件之一即可。分别是资源互斥和不共享、请求和保持条件、资源不可剥夺性、循环等待条件，

</my-details>

<my-details title="同学2的回答">

**什么是死锁：**

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，他们都将无法
再向前推进

因此我们举个例子来描述，如果此时有一个线程A，按照先锁a再获得b的顺序获得锁，而在此同时又有另外一个线程B
按照先锁b再锁a，这是就进入了僵持状态。

**产生死锁的原因：**

可归结如下两点：

1. 竞争资源
* 系统中的资源可以分为两类：
  * 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
  * 另一类资源是不可剥夺资源，当系统把这类资源分配给某进程，再不能强行回收，只能在进程用完后自行释放，如磁带机，打印机等
* 产生死锁中的资源之一是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已经占用了打印机，妥P2继续要求打印机打印那么就会造成阻塞）
* 产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断，信号，消息，缓冲区内的消息等），通常消息顺序不当，就会产生死锁

2. 进程间推进顺序非法
   * 若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
   * 例如，当P1运行到R1，Request（R2）时，将因为R2已经被P2占用而阻塞。。。同理P2也可能因为请求R1而发生进程死锁


**产生死锁的必要条件：**

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

**预防死锁：**

1. 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
2. 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
3. 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
4. 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

* 预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。
* 由于在避免死锁的策略中，允许进程动态地申请资源。
* 因而，系统在进行资源分配之前预先计算资源分配的安全性。
* 若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。
* 其中最具有代表性的避免死锁算法是银行家算法。

银行家算法：
* 首先需要定义状态和安全状态的概念。
* 系统的状态是当前给进程分配的资源情况。
* 因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。
* 安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。
* 如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。

**破解死锁：**

1. 剥夺资源：从其他进程剥夺足够数量的资源给死锁进程，解除死锁状态
2. 撤销进程：可以直接撤销死锁进程或撤销代价最小的进程，直至有足够的资源可用，死锁状态：消除为止；所谓代价是指优先级
运行代价，进程的重要性和价值等。

</my-details>

<my-details title="同学3的回答">

**什么是死锁：**

如果一个进程集合里面的每个进程都在等待这个集合中的其他一个进程（包括自身）才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁

**产生原因：**

1. 因竞争资源发生死锁现象：系统中供多个进程共享的资源的数目不足以满足全部进程的需要时，就会引起对诸资源的竞争而发生死锁现象；
   * 可剥夺资源和不可剥夺资源：可剥夺资源是指某进程在获得该类资源时，该资源同样可以被其他进程或系统剥夺，不可剥夺资源是指当系统把该类资源分配给某个进程时，不能强制收回，只能在该进程使用完成后自动释放
   * 竞争不可剥夺资源：系统中不可剥夺资源的数目不足以满足诸进程运行的要求，则发生在运行进程中，不同的进程因争夺这些资源陷入僵局。


**如何预防：**

破坏请求与保持，循环请求，不可抢占三个条件中的一个

**如何破解：**

如果已经有死锁，可以分配资源给死锁进程，或者撤销某一个死锁进程，让系统从死锁中解放出来

</my-details>


## JS
1. 箭头函数有哪些特点

* 跳转->[箭头函数 - 特点](./../../bigWeb/js/arrowfun.md#特点)

<my-details title="同学1的回答">

没有自己的this，没有arguments对象,不能实例化对象,没有函数提升,call/apply/bind也不能改变其this指向

</my-details>

<my-details title="同学2的回答">

**箭头函数有哪些特点：**

1. 箭头函数是匿名函数
2. 箭头函数的this指向外层作用域的this的值
3. 箭头函数不绑定argument
4. 箭头函数不能用作构造函数
5. 箭头函数没有原型属性
6. 不需要function关键字来创建函数

</my-details>

<my-details title="同学3的回答">

**箭头函数函数的特点：**

匿名函数，没有自己的的this，this指向被定义时的this，
，call、apply、bind也无法改变，没有原型属性，不能用作构造函数，不能使用argumetns,取而代之用rest参数…解决，

</my-details>


## HTML
1. 常见的内联元素有哪些,块元素有哪些（你觉得的，这个题回答前，先别百度）


<my-details title="同学1的回答">

**内联：**

a, abbr, big, br, cite, code, em, i, img, input, kbd, label, small, span, strong, sub, sup, textarea, u

**块级：**

address, blockquote, dl, form, h1-h6, hr, p, pre, div, table, ul, ol

</my-details>
<my-details title="同学2的回答">

**HTMl常用内联元素：**

* span----常用内联容器，定义文本区块
* label----表格标签
* br----换行标签
* em----强调
* strong----粗体强调
* textarea----多行文本输入框
* a----锚点
* img----图片标签
* input----输入框
* font----字体设定

**HTML常见块元素：**

* div----最常见的块儿元素
* address----地址
* block----块应用
* center----居中对齐
* dir----目录列表
* dl----定义列表
* form----表单
* h----标题标签
* hr----水平分隔线
* menu----菜单列表
* ol----有序表单
* p----段落标签
* table----表格
* ul----无序列表

</my-details>
<my-details title="同学3的回答">

**内联元素：**

span,a,,br,em,code,font,I,img,input,label,q,sqan,strong,textarea
 
**块元素:**

header,aside,audio,canvas,dd,dt,div,dl,footer,form,h1-h6,p,table,ul,li,video

</my-details>


## css
1. css是否会阻塞页面渲染
2. 如果是，如何解除

* 跳转->[浏览器专题系列 - 阻塞](./../../bigWeb/browser/block.md)

<my-details title="同学1的回答">

答：浏览器渲染页面前会先构建DOM树和CSSOM树，因此CSS过多会阻塞页面渲染

答：使用媒体查询仅加载当前情况需要的样式,使用css in js, 再利用js defer延迟加载的特性将部分不重要的css延迟加载

</my-details>
<my-details title="同学2的回答">

**CSS是否会阻塞页面渲染**

浏览器大致渲染过程：
1. HTML解析文件，生成DOM TREE，解析CSS文件生成CSSOM TREE
2. 将Dom Tree和CSSOM Tree结合，生成Render Tree（渲染树）
3. 根据Render Tree渲染绘制

Dom解析和Css解析是两个并行的进程，所以这也解释了为什么Css加载不会阻塞Dom的解析

然而，由于Render Tree是依赖于Dom Tree和CSSOM Tree的，所以他必须等到CSSOMTree构建完成，

也就是CSS资源加载完成（或者CSS资源加载失败）后，才能开始渲染，因此，CSS加载是会阻塞Dom的渲染的

由于JS可能会操作之前的Dom节点和Css样式，因此浏览器会维持html中CSS和js的顺序。

因此样式会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。

结论：
1. css加载不会阻塞DOM树的解析
2. css加载会阻塞DOM树的渲染
3. css加载会阻塞后面js语句的执行

解决办法：
1. 使用CDN（因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间）
2. 对css进行压缩（可以用很多打包工具，比如webpack）
3. 合理的使用缓存
4. 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式（内联样式的一个缺点就是不能缓存）

</my-details>

<my-details title="同学3的回答">

1. 会的
 
2. 页面初始渲染所需要的JS和CSS可以直接在 `<head>` 标签中以代码形式插入。所有的外部文件引用可以放在页面内容之后，对于JS文件也可以采用异步加载。也可以使用媒体查询，仅查询当前情况需要的样式

</my-details>

\>[戳我查看-同学4的所有回答](https://www.cnblogs.com/banshanliang/p/14168767.html)

